### 1. Какой самый эффективный способ конкатенации строк?
Тип Builder из пакета strings используется для эффективного построения строки с использованием методов Write. Это сводит к минимуму копирование памяти при последовательном добавление новых строк.

### 2. Что такое интерфейсы, как они применяются в Go?
Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. То есть интерфейсы определяют некоторый функционал, но не реализуют его.  
В Go интерфейсы реализуются неявным образом. Конкретный
тип не объявляет о том, что он реализует интерфейс. Если набор методов
конкретного типа содержит все методы из набора методов интерфейса, то этот
конкретный тип реализует интерфейс. Это означает, что этот конкретный тип
может быть присвоен переменной или полю, в качестве типа которого указан
данный интерфейс.  

### 3. Чем отличаются RWMutex от Mutex?
Mutex блокирует любые действия с критической секцией для других горутин.
RWMutex при использовании блокировки на чтение позволяет нескольким горутинам получить совместный доступ к критической секцией для получения данных из нее.

### 4. Чем отличаются буферизированные и не буферизированные каналы?
После каждой операции записи в открытый небуферизованный канал производящая запись горутина делает паузу до тех пор, пока другая горутина не произведет чтение из этого канала. И точно так же после каждой операции чтения из открытого небуферизованного канала производящая чтение горутина делает паузу до тех пор, пока другая горутина не произведет запись в этот канал.  
Буферизованные каналы буферизуют без блокировки некоторое ограниченное количество операций записи. Если буфер заполнится еще до выполнения каких-либо операций чтения из канала, то следующая операция записи в этот канал приостановит записывающую горутину до тех пор, пока не будет произведено чтение из канала. К такой же блокировке, как в случае записи в канал с заполненным буфером, приводит и попытка чтения из канала с пустым буфером.

### 5. Какой размер у структуры struct{}{}?
0 байт.

### 6. Есть ли в Go перегрузка методов или операторов?
Go не поддерживает перегрузку методов и операторов. Это упрощает чтение и написание кода.

### 7. В какой последовательности будут выведены элементы map[int]int?

Пример:
```go
m[0]=1
m[1]=124
m[2]=281
```
Порядок обхода элементов мапы может быть произвольным. Но функции форматирования (такие как fmt.Println) выводят их в порядке возрастания ключей.

### 8. В чем разница make и new?
Make используется только для создания срезов, мап и каналов, New используется для любых типов.  
Make возвращает значение создаваемого типа, New возвращает указатель на создаваемый тип.
Make выделяет место в памяти и инициализирует инициализирует внутреннюю структуру данных, подготавливая значение для использования. New выделяет место в памяти, но не инициализирует внутреннюю структуру данных.

### 9. Сколько существует способов задать переменную типа slice или map?
Задать переменную типа среза или мап можно с помощью литералов этих структур или с помощью функции make().  
Можно присвоить значение среза и мапы уже существующим переменным этого типа.
Срез можно определить через приведение nil к нужному типу
Если использовать функцию new(), вернется указатель на создаваемый тип, и необходимо использовать указатель на литерал среза или мапы, или указатель на результат функции make().


### 10. Что выведет данная программа и почему?

```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
Программа выведет:\
1\
1\
Потому что в функцию update передается копия указателя и изменяется значение копии указателя.

### 11. Что выведет данная программа и почему?

```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

Программа выведет:
```sh
4
2
0
1
3
fatal error: all goroutines are asleep - deadlock!
```

Порядок вывода чисел произвольный.
Блокировка происходит потому что WaitGroup в главной горутине никогда не обнулится, в функции горутин, необходимо пердавать указатель на WaitGroup, иначе в горутинах будет использоваться копия WaitGroup и вызов метода Done(), не будет обнулять счетчик WaitGroup в главной горутине.

### 12. Что выведет данная программа и почему?

```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
Программа выведет:
0
Потому что в блоке if создается переменная n, которая затеняет переменную n, вне блока if.

### 13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
Программа выведет:\
[100 2 3 4 5]\
\
В функцию передается копия структуры среза, в которой указатель на тот же массив, что и в исходном срезе, поэтому при измении 0 индекса в копии среза, изменяется значении и в исходном срезе.
Изменении длины и емкости копии среза внутри функции, не изменяет длину и емкость оригинального среза.
Если в копии среза изменится емкость, то этот срез будет указывать на новую область в памяти. Если при изменении длины копии среза, емкости исходного массива в блоке памяти будет достаточно, чтобы для среза не выделять новое место в памяти, то длина копии изменится, новые значения будут добавлены в исходный массив используемый и копией и оригиналом, но длина оригинала среза не измениться, и он не сможет увидеть эти значения, потому что они выходят за пределы его длины.
В случае данной программы измениться емкость в копии среза внутри функции, и новый элемент будет добавлен уже в новую область памяти. У оригинал и копии среза, теперь будут ссылатся на разные области в памяти.

### 14. Что выведет данная программа и почему?

```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
Программа выведет:\
[b b a][a a]\
\
В одну строку выведет потому что нет знака переноса строки, в методе Print нужно явно это указывать.
В функцию передается копия структуры среза, в которой указатель на тот же массив.  
Изменении длины и емкости копии среза внутри функции, не изменяет длину и емкость оригинального среза.
Если в копии среза изменится емкость, то этот срез будет указывать на новую область в памяти.  
В данной программе в функции изменяется емкость копии среза, а значит это срез ссылается на новую область памяти, и все изменения в ней, не затрагивают область памяти оригинального среза.